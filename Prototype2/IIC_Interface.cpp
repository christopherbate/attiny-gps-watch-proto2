//---------------------------------------------------------------------------------------------
// IIC_Interface.cpp
//
// Created: 5/11/2017 9:09:43 AM
// Author : Christopher Bate
// BASED ON THE ATMEL AVR APPLICATION NOTE AVR310
//
// Provides all the necessary functions to initialize, and communicate as an IIC Master on pins 5 and 7 usin
// the USI
//
// Requirements:
//---------------------------------------------------------------------------------------------
#ifndef F_CPU
#define F_CPU 8000000UL
#endif 

#include "IIC_Interface.h"
#include <avr/io.h>
#include <util/delay.h>

//---------------------------------------------------------------------------------------------
// IIC_Init - Main API Function
/*
	Description: Initializes the microcontroller for using the USI.  
*/
//---------------------------------------------------------------------------------------------
void IIC_Init()
{
		// Pre-fill USI data register so we don't accidentally drop low
		USIDR = 0xFF;
		
		PORT_USI |= (1<<PIN_USI_SDA);           // Enable pullup on SDA, to set high as released state.
		PORT_USI |= (1<<PIN_USI_SCL);
		
		// Set the Data and Clock lines to output;
		DDRB |= (1<<DATAPIN)|(1<<CLOCKPIN);
		
		// Set the Control Register -------------------------------------------
		// Disable start Condition Interrupt because this is the master.
		USICR &= ~(1<<USISIE);
		
		// Disable counter overflow interrupt. We will handle this by polling.
		USICR &= ~(1<<USIOIE);
		
		// Set Two-Wire Mode (open drain, etc)
		USICR |= (1<<USIWM1);
		USICR &= ~(1<<USIWM0);
		
		// Select the clock source.
		USICR |= (1<<USICS1) | (1<<USICLK);
		USICR &= ~(1<<USICS0); // Positive edge to clock the data register.
		
		// Reset all flags in the Status Register--------------------------------------------
		// The last bit mask resets the count.
		USISR = (1<<USISIF) | (1<<USIOIF) | (1<<USIPF) | (1<<USIDC) | (0x0<<USICNT0);
}

//---------------------------------------------------------------------------------------------
// SendStartIIC - Main API Function
/*
	Description: Sends an address and awaits for acknowledgment.
	
	Requirements: well-formed slave address is provided 
	
	Outputs: True if acknowledgment received, false if no acknowledgment. 
*/
//---------------------------------------------------------------------------------------------
bool SendStartIIC( unsigned char addr)
{
	// The start condition is generated by causing a DATA high to low transition
	// while the clock is high. After that, you must bring the clock down.
	PORTB |= (1<<PIN_USI_SCL);

	// check that the clock "comes high"
	while( !(PORTB & (1<<CLOCKPIN)))
	{
		// Do nothing and wait for condition to true
	}
	// Delay for "negative clock edge" low time *is this necessary?
	_delay_us(TWI_LOW); 
	
	// Write SDA low
	PORTB &= ~(1<<DATAPIN);
	
	// Delay for a positive clock edge time
	_delay_us(TWI_HIGH);
	
	// Now bring the clock low in preparation for data
	PORTB &= ~(1<<CLOCKPIN);
	
	// Release SDA
	PORTB |= (1<<PIN_USI_SDA);
	
	// We have now gone through one clock cycle. 
	// Begin address
	//unsigned char msgWrite = 0x00; // General call address, write
	USIDR = addr; // Fill the buffer.
	USISR = (1<<USISIF)|(1<<USIOIF)|(1<<USIPF)|(1<<USIDC)| (0x0<<USICNT0);
	unsigned  char controlReg =  (0<<USISIE)|(0<<USIOIE)|                 // Interrupts disabled
								(1<<USIWM1)|(0<<USIWM0)|                 // Set USI in Two-wire mode.
								(1<<USICS1)|(0<<USICS0)|(1<<USICLK)|     // Software clock strobe as source.
								(1<<USITC);                              // Toggle Clock Port.
	
	do
	{
		// The data line is already set, being controlled by the USI
		// machinery. All we have to do is strobe the clock.
		// Delay for the minimum required of a low cycle.
		_delay_us(TWI_LOW);
		
		USICR = controlReg; // The clock will now go high.
		
		// Wait for the clock to become high (in case slave is clock
		// stretching.
		while( !(PINB & (1<<CLOCKPIN)))
		{
			// Do nothing.
		}
		
		// Perform low delay minimum for high clock
		_delay_us(TWI_HIGH);
		
		// The counter and clock are automatically being cycled.
		
		// Generate a low clock edge.
		USICR = controlReg;
	} while( !(USISR & (1<<USIOIF)));
	
	// A this point we are ready for an acknowledge. 
	// Enable SDA as input and reset counter
	DDRB &= ~(1<<DATAPIN);
	USISR = (1<<USISIF)|(1<<USIOIF)|(1<<USIPF)|(1<<USIDC)| (0xE<<USICNT0);
	
	do 
	{
		// We are in the "low" clock area, so delay a minimum.
		_delay_us(TWI_LOW);
	
		// Strobe clock high and check for message. 
		USICR = controlReg;
	
		// Let clock become high
		while(!(PINB & (1<<CLOCKPIN)))
		{
			// Do nothing
		}
	
		// Delay high
		_delay_us(TWI_HIGH);
	
		// Set clock to low.
		USICR = controlReg;
	}while(!(USISR & (1<<USIOIF)));
	
	
	
	// Check if acknowledged.
	if(USIDR & (1<<0)) // nack bit is zero position
	{
		return false; // not acklowledged. 
	}
	// Reset SDA to output
	USIDR = 0xFF;
	DDRB |= (1<<DATAPIN);
	
	// All else, we succeeded
	return true;
}

//---------------------------------------------------------------------------------------------
// SendbyteIIC - Main API Function
/*
	Description: Sends byte out over the USI
	
	Requirements: well-formed data is provided to "msg"
	
	Outputs: True if acknowledgment received, false if no acknowledgment. 
*/
//---------------------------------------------------------------------------------------------
bool SendByteIIC( unsigned char msg)
{
	// Now bring the clock low in preparation for data
	PORTB &= ~(1<<CLOCKPIN);
	
	// Begin Data.
	USIDR = msg; // Fill the buffer.
	USISR = (1<<USISIF)|(1<<USIOIF)|(1<<USIPF)|(1<<USIDC)| (0x0<<USICNT0);
	unsigned  char controlReg =  (0<<USISIE)|(0<<USIOIE)|                 // Interrupts disabled
				(1<<USIWM1)|(0<<USIWM0)|                 // Set USI in Two-wire mode.
				(1<<USICS1)|(0<<USICS0)|(1<<USICLK)|     // Software clock strobe as source.
				(1<<USITC);                              // Toggle Clock Port.
	
	do
	{
		// The data line is already set, being controlled by the USI
		// machinery. All we have to do is strobe the clock.
		// Delay for the minimum required of a low cycle.
		_delay_us(TWI_LOW);
		
		USICR = controlReg; // The clock will now go high.
		
		// Wait for the clock to become high (in case slave is clock
		// stretching.
		while( !(PINB & (1<<CLOCKPIN)))
		{
			// Do nothing.
		}
		
		// Perform low delay minimum for high clock
		_delay_us(TWI_HIGH);
		
		// The counter and clock are automatically being cycled.
		
		// Generate a low clock edge.
		USICR = controlReg;
	} while(!(USISR & (1<<USIOIF)));
	
	// A this point we are ready for an acknowledge.
	// Enable SDA as input and reset counter
	DDRB &= ~(1<<DATAPIN);
	USISR = (1<<USISIF)|(1<<USIOIF)|(1<<USIPF)|(1<<USIDC)| (0xE<<USICNT0);
	
	do
	{
		// We are in the "low" clock area, so delay a minimum.
		_delay_us(TWI_LOW);
		
		// Strobe clock high and check for message.
		USICR = controlReg;
		
		// Let clock become high
		while(!(PINB & (1<<CLOCKPIN)))
		{
			// Do nothing
		}
		
		// Delay high
		_delay_us(TWI_HIGH);
		
		// Set clock to low.
		USICR = controlReg;
	}while(!(USISR & (1<<USIOIF)));
	
	// Check if acknowledged.
	if(USIDR & (1<<0)) // nack bit is zero position
	{
		return false; // not acklowledged.
	}
	// Reset SDA to output
	USIDR = 0xFF;
	DDRB |= (1<<DATAPIN);
	
	// All else, we succeeded
	return true;
}

//---------------------------------------------------------------------------------------------
// SendStopIIC - Main API Function
/*
	Description: Sends a stop condition
	
	Requirements: None
	
	Outputs: none
*/
//---------------------------------------------------------------------------------------------
void SendStopIIC()
{
	// The stop condition is generated by causing a DATA low to high transition
	// while the clock is high. After that, you must bring the clock down.
	
	// Drive data low
	PORTB &= ~(1<<DATAPIN);
	PORT_USI |= (1<<PIN_USI_SCL); // Make sure clock is high.
	
	// check that the clock "comes high"
	while( !(PINB & (1<<CLOCKPIN) ) )
	{
		// Do nothing and wait for condition to true
	
	}
	// Delay for "positie edge
	_delay_us(TWI_HIGH);
	
	// Write SDA high
	PORTB |= (1<<DATAPIN);
	
	// Delay for a positive clock edge time
	_delay_us(TWI_LOW);
}